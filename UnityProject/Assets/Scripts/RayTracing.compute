#pragma kernel CSMain

#define PI 3.141592
#define inf 100000000
#define MAX_BOUNCES 8
#define ALPHA 10000


// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;
float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;

Texture2D<float4> _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

float4 _LightVector;

float2 _PixelOffset;
///////////////////////////////////////////


#include "SceneItems.hlsl"

StructuredBuffer<MeshObject> _MeshObjects;
StructuredBuffer<float3> _Vertices;
StructuredBuffer<int> _Indices;
StructuredBuffer<float3> _Normals;

#include "Random.hlsl"
#include "RayFunctions.hlsl"
#include "RayGeometry.hlsl"


// Set from RayTracing.cs ////////
//StructuredBuffer<Sphere> _SphereBuffer;
//////////////////////////////////


// Given a specific ray find the nearest collision point by iterating over each object in the scene.
RayCollision TraceRays(Ray ray)
{
	RayCollision Collision = CreateRayCollision();

	//GroundPlaneRayIntersection(ray, Collision);
	
	uint numSpheres, stride;
	/*
	_SphereBuffer.GetDimensions(numSpheres, stride);

	for (uint i = 0; i < numSpheres; i++)
		SphereRayIntersection(ray, Collision, _SphereBuffer[i]);

	float3 v0 = float3(0, 0, -15);
	float3 v1 = float3(15, 0, -15);
	float3 v2 = float3(0, 15 * sqrt(2), -15);

	TriangleCollisionPoint triangleCollisionPoint;

	
	if (TriangleRayIntersection(ray, v0, v1, v2, triangleCollisionPoint))
		if (triangleCollisionPoint.Distance > 0 && triangleCollisionPoint.Distance < Collision.Distance)
		{
			Collision.Distance = triangleCollisionPoint.Distance;
			Collision.Position = triangleCollisionPoint.Position;
			Collision.positionNormal = normalize(cross(v1 - v0, v2 - v0));
			Collision.Albedo = float3(1.0f, 1.0f, 1.0f);
			Collision.Specular = float3(0.0f, 0.0f, 0.0f);
			Collision.Emission = float3(1.0f, 1.0f, 1.0f);
		}

	 v0 = float3(15, 15 * sqrt(2), -15);
	 v1 = float3(15, 0, -15);
	 v2 = float3(0, 15 * sqrt(2), -15);


	if (TriangleRayIntersection(ray, v0, v1, v2, triangleCollisionPoint))
		if (triangleCollisionPoint.Distance > 0 && triangleCollisionPoint.Distance < Collision.Distance)
		{
			Collision.Distance = triangleCollisionPoint.Distance;
			Collision.Position = triangleCollisionPoint.Position;
			Collision.positionNormal = normalize(cross(v1 - v0, v2 - v0));
			Collision.Albedo = float3(1.0f, 1.0f, 1.0f);
			Collision.Specular = float3(0.0f, 0.0f, 0.0f);
			Collision.Emission = float3(1.0f, 0.0f, 1.0f);
		}
	*/

	// Test collisions with all the meshes in the scene.

	uint count;
	
	_MeshObjects.GetDimensions(count, stride);

	for (int j = 0; j < count; j++)
	{
		MeshRayIntersection(ray, Collision, _MeshObjects[j]);
	}
	

	return Collision;
}

// Given a ray and its nearest collision find which colour and how much it contributes to the final pixel color. Also keep track of the intensity of bounced rays. For materials with both specular and diffuse relections randomly pick one of the two to trace a ray for, weighted
// how strong the respective reflections are.
float3 ShadeRay(inout Ray ray, RayCollision collision)
{
	if (collision.Distance < inf)
	{	
		float specProb = dot(collision.Specular, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
		float diffProb = dot(collision.Albedo, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));

		specProb /= (specProb + diffProb);
		diffProb = 1 - specProb;

		float decisionFactor = rand();

		ray.Origin = collision.Position + collision.positionNormal * 0.001;

		float3 Contribution;

		// Diffuse
		if (decisionFactor < diffProb)
		{
			ray.Direction = SampleHemisphere(collision.positionNormal, 1);
			Contribution = 1.0/diffProb * collision.Albedo;
		}
		else // Specular
		{
			float3 perfectReflectedRay = reflect(ray.Direction, collision.positionNormal);
			ray.Direction = SampleHemisphere(perfectReflectedRay, ALPHA);
			float cosFactorPhong = (ALPHA + 2.0) / (ALPHA + 1.0);
			Contribution = 1.0/specProb * collision.Specular * cosFactorPhong ;
		}


		ray.Intensity *=  Contribution * saturate(dot(collision.positionNormal, ray.Direction));

		return collision.Emission;
	}
	else
	{
		// If a ray hits nothing, sample a pixel from the skybox.
		ray.Intensity = 0.0f;

		float theta = acos(ray.Direction.y) / -PI;
		float phi = atan2(ray.Direction.x, -ray.Direction.z) / -PI * 0.5f;
		return _SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, float2(phi, theta), 1).xyz;
	}
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Target[id.xy] = Source[id.xy];
	Pixel = id.xy;

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = (id.xy + _PixelOffset) / float2(width,height) * 2 - 1;

	// Create the camera ray for that specific pixel.
    Ray cameraRay = CreateCameraRay(uv);

	float3 pixelColor = float3(0,0,0);

	// Trace the ray for this pixel. Each time it hits something a contribution to the final pixel is added and it's origin and direction are updated.
	// That ray is then traced again to check for further reflections up to MAX_BOUNCES times.
	int i = 0;
	while (i < MAX_BOUNCES)
	{
		i++;

		RayCollision Collision = TraceRays(cameraRay);
		pixelColor += cameraRay.Intensity * ShadeRay(cameraRay, Collision);

		// If the energy of the ray is depleted for all thee color channels
		if (!any(cameraRay.Intensity))
			break;
	}

	Target[id.xy] = float4(pixelColor,1);
}
