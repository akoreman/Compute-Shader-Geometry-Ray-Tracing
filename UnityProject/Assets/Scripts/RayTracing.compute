#pragma kernel CSMain

#define PI 3.141592
#define inf 1000000
#define MAX_BOUNCES 8
#define ALPHA 100000


// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;
float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;

Texture2D<float4> _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

float4 _LightVector;

float2 _PixelOffset;
///////////////////////////////////////////


#include "SceneItems.hlsl"
#include "Random.hlsl"
#include "RayFunctions.hlsl"
#include "RayGeometry.hlsl"


// Set from RayTracing.cs ////////
StructuredBuffer<Sphere> _SphereBuffer;
//////////////////////////////////


// Given a specific ray find the nearest collision point by iterating over each object in the scene.
RayCollision TraceRays(Ray ray)
{
	RayCollision Collision = CreateRayCollision();

	GroundPlaneRayIntersection(ray, Collision);

	uint numSpheres, stride;
	_SphereBuffer.GetDimensions(numSpheres, stride);

	for (uint i = 0; i < numSpheres; i++)
		SphereRayIntersection(ray, Collision, _SphereBuffer[i]);

	return Collision;
}

// Given a ray and its nearest collision find which colour and how much it contributes to the final pixel color. Also keep track of the energy of bounced rays.
float3 ShadeRay(inout Ray ray, RayCollision collision)
{
	if (collision.Distance < inf)
	{	
		
		float specProb = dot(collision.Specular, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
		float diffProb = dot(collision.Albedo, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));

		specProb /= (specProb + diffProb);
		diffProb = 1 - specProb;

		float decisionFactor = rand();

		ray.Origin = collision.Position + collision.positionNormal * 0.001;

		float3 Contribution;

		// Diffuse
		if (decisionFactor < diffProb)
		{
			ray.Direction = SampleHemisphere(collision.positionNormal, 1);
			Contribution = 1.0/diffProb * collision.Albedo;
		}
		else
		{
			float3 perfectReflectedRay = reflect(ray.Direction, collision.positionNormal);
			ray.Direction = SampleHemisphere(collision.positionNormal, ALPHA);
			float cosFactorPhong = (ALPHA + 2.0) / (ALPHA + 1.0);
			Contribution = 1.0/specProb * collision.Specular * cosFactorPhong ;
		}


		ray.Intensity *=  Contribution * saturate(dot(collision.positionNormal, ray.Direction));

		return collision.Emission;
	}
	else
	{
		// If a ray hits nothing, sample a pixel from the skybox.
		ray.Intensity = 0.0;

		float theta = acos(ray.Direction.y) / -PI;
		float phi = atan2(ray.Direction.x, -ray.Direction.z) / -PI * 0.5f;
		return _SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, float2(phi, theta), 1).xyz;
	}
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Target[id.xy] = Source[id.xy];
	Pixel = id.xy;

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = (id.xy + _PixelOffset) / float2(width,height) * 2 - 1;

	// Create the camera ray for that specific pixel.
    Ray cameraRay = CreateCameraRay(uv);

	float3 pixelColor = float3(0,0,0);

	// Trace the ray for this pixel. Each time it hits something a contribution to the final pixel is added and it's origin and direction are updated.
	// That ray is then traced again to check for further reflections up to MAX_BOUNCES times.
	int i = 0;
	while (i < MAX_BOUNCES)
	{
		i++;

		RayCollision Collision = TraceRays(cameraRay);
		pixelColor += cameraRay.Intensity * ShadeRay(cameraRay, Collision);

		// If the energy of the ray is depleted for all thee color channels
		if (!any(cameraRay.Intensity))
			break;
	}

	Target[id.xy] = float4(pixelColor,1);
}
