#pragma kernel CSMain

#define PI 3.141592
#define inf 1000000
#define MAX_BOUNCES 8

// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;
float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;

Texture2D<float4> _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;
///////////////////////////////////////////

struct Ray
{
	float3 Origin;
	float3 Direction;
	float3 Energy;
};

Ray CreateRay(float3 Origin, float3 Direction)
{
	Ray ray;

	ray.Origin = Origin;
	ray.Direction = Direction;
	ray.Energy = float3(1,1,1);

	return ray;
}

Ray CreateCameraRay(float2 xy)
{
	//float3 Origin = mul(_CameraToWorldProj, float4(0,0,0,1)).xyz;
	float3 Origin = _CameraPosition.xyz;

    float3 Direction = mul(_CameraInverseProj, float4(xy,0,1)).xyz;
    Direction = mul(_CameraToWorldProj, float4(Direction,0)).xyz;
    Direction = normalize(Direction);

	return CreateRay(Origin,Direction);
}

struct RayCollision
{
	float3 Position;
	float Distance;
	float3 positionNormal;
};

RayCollision CreateRayCollision()
{
	RayCollision Collision;

	Collision.Position = float3(0,0,0);
	Collision.Distance = inf;
	Collision.positionNormal = float3(0,0,0);

	return Collision;
};

void GroundPlaneRayIntersection(Ray ray, inout RayCollision collision)
{
	// Direction is unit length, so origin-plane intersection is at distance O.y/D.y, D.y < 0 if it hits the plane so we need a negative.
	float Distance = -ray.Origin.y / ray.Direction.y;

	// Check whether it points down and whether it hits the plane before reaching the skybox.
	if (Distance > 0.0 && Distance < collision.Distance)
	{
		collision.Distance = Distance;
		collision.Position = ray.Origin + Distance * ray.Direction;
		collision.positionNormal = float3(0,1,0);
	}
	
}

void SphereRayIntersection(Ray ray, inout RayCollision collision, float3 sphereposition, float sphereradius)
{
	// Vector pointing from the Origin to the center of the sphere.
	float3 distanceVector = ray.Origin - sphereposition;

	// p1 defines the point where the ray enters the sphere, the dot product is correlated with the overlap between the distance vector and the ray direction. 
	// Large overlap -> ray direction and distance vector close to the same direction.
	float p1 = -dot(ray.Direction, distanceVector);

	// Check whether the ray hits the sphere.
	float p2Squared = p1*p1 - dot(distanceVector,distanceVector) + sphereradius*sphereradius;

	if (p2Squared < 0)
		return;
	
	// Find the point where the ray exits the sphere.
	float p2 = sqrt(p2Squared);

	// Find the distance between the ray origin and the entry (or exit) point of the sphere.
	float Distance;

	if(p1-p2 > 0)
		Distance = p1-p2;
	else
		Distance = p1+p2;

	if (Distance > 0.0 && Distance < collision.Distance)
	{
		collision.Distance = Distance;
		collision.Position = ray.Origin + Distance * ray.Direction;
		// Find the normal vector.
		collision.positionNormal = normalize(collision.Position - sphereposition);
	}
}

// Given a specific ray find the nearest collision point by iterating over each object in the scene.
RayCollision TraceRays(Ray ray)
{
	RayCollision Collision = CreateRayCollision();

	//GroundPlaneRayIntersection(ray, Collision);
	SphereRayIntersection(ray, Collision, float3(0,1,0),.5);
	SphereRayIntersection(ray, Collision, float3(2,1,2),.5);
	SphereRayIntersection(ray, Collision, float3(0,1,2),.5);
	SphereRayIntersection(ray, Collision, float3(2,1,0),.5);

	return Collision;
}

// Given a ray and it's nearest collision find which colour and how much it contributes to the final pixel color. Also keep track of the energy of bounced rays.
float3 ShadeRay(inout Ray ray, RayCollision collision)
{
	if (collision.Distance < inf)
	{	
        float3 specular = float3(0.8f, 0.8f, 0.8f);

		ray.Origin = collision.Position + collision.positionNormal + 0.001;

		ray.Direction = reflect(ray.Direction, collision.positionNormal);

        ray.Energy *= specular;

        return float3(0.0, 0.0, 0.0);
	}
	else
	{
		// If a ray hits nothing, sample a pixel from the skybox.
		ray.Energy = 0.0;

		float theta = acos(ray.Direction.y) / -PI;
		float phi = atan2(ray.Direction.x, -ray.Direction.z) / -PI * 0.5f;
		return _SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, float2(phi, theta), 1).xyz;
	}
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Target[id.xy] = Source[id.xy];

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = id.xy / float2(width,height) * 2 - 1;

	// Create the camera ray for that specific pixel.
    Ray cameraRay = CreateCameraRay(uv);

	float3 pixelColor = float3(0,0,0);

	// Trace the ray for this pixel. Each time it hits something a contribution to the final pixel is added and it's origin and direction are updated.
	// That ray is then traced again to check for further reflections up to MAX_BOUNCES times.
	int i = 0;
	while (i < MAX_BOUNCES)
	{
		i++;

		RayCollision Collision = TraceRays(cameraRay);
		pixelColor += cameraRay.Energy * ShadeRay(cameraRay, Collision);

		// If the energy of the ray is depleted for all thee color channels
		if (!any(cameraRay.Energy))
			break;
	}

	Target[id.xy] = float4(pixelColor,1);
}
